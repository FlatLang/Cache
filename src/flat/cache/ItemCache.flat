package flat/cache

import flat/time
import flat/future
import flat/log

class<TValue> {
    static Logger log = Logger(ItemCache.class)

    var Future<TValue> pendingGet

    private construct(
        private CacheStore<Object, TValue> cacheStore,
        private Long? lifetime = null,
        private String key = ""
    ) {}

    async checkExpired() -> Bool {
        if (lifetime == null) return false
        if (!cacheStore.checkExpired(key, lifetime)) return false

        invalidate()

        return true
    }

    public async hasValue() -> Bool {
        if (checkExpired()) return false

        return cacheStore.contains(key)
    }

    public async get() -> TValue {
        if (pendingGet) return pendingGet.get()

        if (checkExpired()) return null

        return cacheStore.get(key)
    }

    public async store(TValue value) -> TValue {
        let stored = cacheStore.store(key, value)

        return stored
    }

    public async invalidate() {
        cacheStore.invalidate(key)
    }

    public async getOrStore(async storeFunc() -> TValue) -> TValue {
        let value = get()

        if (value) return value

        return store(storeFunc())
    }

    public async getThenStoreIfInvalid(async storeFunc() -> TValue) -> TValue {
        if (pendingGet) {
            log.debug("Returning existing pendingGet")
            return pendingGet.get()
        }

        let value = cacheStore.get(key)

        if (!value) {
            log.debug("Value does not exist. Calculating immediately")
            return store(storeFunc())
        }

        if (!checkExpired()) {
            log.debug("Value exists and is not expired. Returning existing value")

            return value
        }

        log.debug("Value exists but is expired. Returning existing value and creating pendingGet future to calculate the new value")

        pendingGet = Future.from({
            let stored = store(storeFunc())

            pendingGet = null

            return stored
        })

        return value
    }

    public static class Builder<TValue> {
        var Long? lifetime
        var CacheStore<Object, TValue> cacheStore
        var String? key

        public withLifetime(Long ms) => this {
            lifetime = ms
        }

        public withStore<TValue>(CacheStore<Object, TValue> value) -> Builder<TValue> => this {
            cacheStore = value
        }

        public withKey(String key) => this {
            this.key = key
        }

        public build() -> ItemCache<TValue> {
            return ItemCache(
                cacheStore: cacheStore == null ? MapCacheStore() : cacheStore,
                lifetime: lifetime,
                key: key ?: ""
            )
        }
    }
}
